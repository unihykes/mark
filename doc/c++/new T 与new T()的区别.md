new T 与new T()的区别
①T *p =new T;

②T *p =new T();

这两类用法不同点的总结。

 

1.若T为类类型，且用户定义了构造函数，则两种形式的效果完全相同，都会调用这个定义了的构造函数来初始化内部成员变量，但是如果此构造函数中并未对成员变量初始化，则这个时候内部的成员变量进行默认初始化——值是未定义的。

2.若T为类类型，但是用户并没有定义任何构造函数，则我们可以知道编译器会为该类合成一个默认的构造函数，这个时候上述两种形式的结果就不同了，①的类内部的成员变量这个时候执行默认初始化，其值是未定义的。但是在②中就不同了，加了括号后，p内部的成员变量会执行值初始化，即以0的形式进行初始化（整数就为0，bool就为false，string 就为空）

3.若T为内置类型，则①的形式中*p的值为未定义的，②中进行值初始化如上。

————————————————
版权声明：本文为CSDN博主「iaccepted」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/iaccepted/article/details/38613089


同理:
std::make_shared和std::make_shared_for_override;