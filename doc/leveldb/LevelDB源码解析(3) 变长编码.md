https://blog.csdn.net/damontive/article/details/115840922



LevelDB的变长编码
LevelDB的解决方案是把size域每个字节的bit0设置为标记位，bit1~bit7存储size的值。如果bit0为0，表示size域到当前字节结束。下一个字节就是数据域了，如果bite0为1，表示下一个字节还是size域。

比如：

size=7，size域只有一个字节，二进制编码为 00000111，变长编码为00000111。bit0为0，表示当前字节是size域最后一个字节。
size=300，size域有两个字节，二进制编码为 0000010 0101100，这里为了方便理解，二进制bit按照7个bit为一组进行了拆分，变长编码其实只需要给每个7元bit组的前面加一个标记bit即可，最终变长编码为：10000010 00101100。第1个字节的bit0为1，表示size域还没有结束，第2个字节的bit0为0，表示当前字节是size域最后一个字节。
size=300000，size域有三个字节，二进制编码为 0010010 0100111 1100000，变长编码为 10010010 10100111 01100000。
以此类推，实际上可以支持任意大小的size，不过一般2^32的size基本能满足所有需求了。
因为实际使用kv时，大部分的key和value的size都是比较小的，变长编码只需要一个字节或者两个字节基本就能满足需求。这样相对于4个字节的固定编码，节省了至少一半的存储空间。

如果了解大端序和小端序的话，会发现上面的变长编码使用的是大端序，即高位放在了低地址位。大端序在解码和编码时，要比小端序麻烦一些，性能也要差一些，所以实现的时候推荐使用小端序，LevelDB使用的就是小端序实现.
————————————————
版权声明：本文为CSDN博主「胡LiuJia」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/damontive/article/details/115840922